#!/usr/bin/env python3
"""
Comprehensive Test Suite for CS1060 Homework 5 - Vulnerability Scanner
Author: Yann C. Lopez (with AI assistance)
Educational purposes only - testing security vulnerability scanner

This test suite ensures the vulnerability scanner meets all grading requirements:
- Correct port scanning (1-8999, excluding 9000+)
- HTTP Basic Auth testing with all credentials
- SSH password auth testing with all credentials
- Exact RFC 3986 output format
- Silent exception handling
- Verbose mode functionality
- Integration with hw5_server
"""

import pytest
import subprocess
import threading
import time
import sys
import os
import re
import socket
from http.server import BaseHTTPRequestHandler, HTTPServer
import base64
import paramiko
import tempfile
import json
import requests

# Add current directory to path for importing
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

import vulnerability_scanner


class TestHTTPServer:
    """Mock HTTP server for testing"""
    
    def __init__(self, port, username, password, response_text='success'):
        self.port = port
        self.username = username
        self.password = password
        self.response_text = response_text
        self.server = None
        self.thread = None
        
    def start(self):
        """Start the HTTP server in a background thread"""
        class Handler(BaseHTTPRequestHandler):
            def __init__(handler_self, *args, **kwargs):
                handler_self.test_username = self.username
                handler_self.test_password = self.password
                handler_self.test_response = self.response_text
                super().__init__(*args, **kwargs)
            
            def do_GET(handler_self):
                auth_header = handler_self.headers.get('Authorization')
                if not auth_header:
                    handler_self.send_response(401)
                    handler_self.send_header('WWW-Authenticate', 'Basic realm="Test"')
                    handler_self.end_headers()
                    return
                
                try:
                    auth_type, auth_string = auth_header.split(' ', 1)
                    if auth_type.lower() != 'basic':
                        handler_self.send_response(401)
                        handler_self.end_headers()
                        return
                    
                    decoded = base64.b64decode(auth_string).decode('utf-8')
                    username, password = decoded.split(':', 1)
                    
                    if username == handler_self.test_username and password == handler_self.test_password:
                        handler_self.send_response(200)
                        handler_self.send_header('Content-type', 'text/plain')
                        handler_self.end_headers()
                        handler_self.wfile.write(handler_self.test_response.encode())
                    else:
                        handler_self.send_response(401)
                        handler_self.end_headers()
                except Exception:
                    handler_self.send_response(401)
                    handler_self.end_headers()
            
            def log_message(handler_self, format, *args):
                # Suppress logging
                pass
        
        self.server = HTTPServer(('127.0.0.1', self.port), Handler)
        self.thread = threading.Thread(target=self.server.serve_forever, daemon=True)
        self.thread.start()
        time.sleep(0.1)  # Give server time to start
    
    def stop(self):
        """Stop the HTTP server"""
        if self.server:
            self.server.shutdown()
            self.server.server_close()


class TestSSHServer:
    """Mock SSH server for testing"""
    
    def __init__(self, port, username, password, response_text='success'):
        self.port = port
        self.username = username
        self.password = password
        self.response_text = response_text
        self.server_socket = None
        self.thread = None
        self.running = False
        self.server_key = paramiko.RSAKey.generate(2048)
    
    def start(self):
        """Start the SSH server in a background thread"""
        self.running = True
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.server_socket.bind(('127.0.0.1', self.port))
        self.server_socket.listen(5)
        self.server_socket.settimeout(1)
        
        self.thread = threading.Thread(target=self._run, daemon=True)
        self.thread.start()
        time.sleep(0.15)  # Give server time to start
    
    def _run(self):
        """Run the SSH server"""
        while self.running:
            try:
                client, addr = self.server_socket.accept()
                threading.Thread(target=self._handle_connection, args=(client,), daemon=True).start()
            except socket.timeout:
                continue
            except Exception:
                if self.running:
                    continue
                break
    
    def _handle_connection(self, client):
        """Handle SSH connection"""
        transport = None
        try:
            client.settimeout(10)
            transport = paramiko.Transport(client)
            transport.add_server_key(self.server_key)
            
            server = self._SSHServerInterface(self.username, self.password)
            transport.start_server(server=server)
            
            channel = transport.accept(5)
            if channel is not None:
                channel.send(self.response_text.encode())
                time.sleep(0.1)
                channel.close()
        except Exception:
            pass
        finally:
            if transport:
                try:
                    transport.close()
                except Exception:
                    pass
            try:
                client.close()
            except Exception:
                pass
    
    class _SSHServerInterface(paramiko.ServerInterface):
        def __init__(self, username, password):
            self.username = username
            self.password = password
        
        def check_auth_password(self, username, password):
            if username == self.username and password == self.password:
                return paramiko.AUTH_SUCCESSFUL
            return paramiko.AUTH_FAILED
        
        def check_channel_request(self, kind, chanid):
            if kind == 'session':
                return paramiko.OPEN_SUCCEEDED
            return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED
        
        def get_allowed_auths(self, username):
            return 'password'
    
    def stop(self):
        """Stop the SSH server"""
        self.running = False
        if self.server_socket:
            try:
                self.server_socket.close()
            except Exception:
                pass


# ============================================================================
# TEST CASES
# ============================================================================

class TestPortScanning:
    """Test port scanning functionality"""
    
    def test_scan_ports_returns_list(self):
        """Verify scan_ports returns a list"""
        result = vulnerability_scanner.scan_ports('127.0.0.1')
        assert isinstance(result, list), "scan_ports should return a list"
    
    def test_scan_ports_excludes_9000_and_higher(self):
        """Verify ports 9000+ are excluded from scanning"""
        # Start a server on port 9001
        server = TestHTTPServer(9001, 'admin', 'admin')
        server.start()
        
        try:
            result = vulnerability_scanner.scan_ports('127.0.0.1')
            assert 9001 not in result, "Port 9001 should not be scanned (9000+ excluded)"
            assert all(port < 9000 for port in result), "All scanned ports must be < 9000"
        finally:
            server.stop()
    
    def test_scan_ports_includes_valid_ports(self):
        """Verify scan includes ports in 1-8999 range"""
        # Start a server on a valid port
        port = 8123
        server = TestHTTPServer(port, 'admin', 'admin')
        server.start()
        
        try:
            time.sleep(0.3)
            result = vulnerability_scanner.scan_ports('127.0.0.1')
            assert port in result, f"Port {port} should be detected as open"
        finally:
            server.stop()
    
    def test_scan_returns_sorted_ports(self):
        """Verify ports are returned in sorted order"""
        result = vulnerability_scanner.scan_ports('127.0.0.1')
        assert result == sorted(result), "Ports should be returned in sorted order"


class TestHTTPAuthentication:
    """Test HTTP Basic Authentication functionality"""
    
    def test_http_auth_success_admin(self):
        """Test successful HTTP auth with admin credentials"""
        port = 8765
        server = TestHTTPServer(port, 'admin', 'admin', 'success')
        server.start()
        
        try:
            result = vulnerability_scanner.try_http_auth('127.0.0.1', port, 'admin', 'admin')
            assert result == 'success', "Should successfully authenticate with admin:admin"
        finally:
            server.stop()
    
    def test_http_auth_success_root(self):
        """Test successful HTTP auth with root credentials"""
        port = 8766
        server = TestHTTPServer(port, 'root', 'abc123', 'success')
        server.start()
        
        try:
            result = vulnerability_scanner.try_http_auth('127.0.0.1', port, 'root', 'abc123')
            assert result == 'success', "Should successfully authenticate with root:abc123"
        finally:
            server.stop()
    
    def test_http_auth_success_skroob(self):
        """Test successful HTTP auth with skroob credentials"""
        port = 8767
        server = TestHTTPServer(port, 'skroob', '12345', 'success')
        server.start()
        
        try:
            result = vulnerability_scanner.try_http_auth('127.0.0.1', port, 'skroob', '12345')
            assert result == 'success', "Should successfully authenticate with skroob:12345"
        finally:
            server.stop()
    
    def test_http_auth_custom_response(self):
        """Test HTTP auth with custom server response (not 'success')"""
        port = 8768
        custom_response = 'schwartz'
        server = TestHTTPServer(port, 'admin', 'admin', custom_response)
        server.start()
        
        try:
            result = vulnerability_scanner.try_http_auth('127.0.0.1', port, 'admin', 'admin')
            assert result == custom_response, f"Should return custom response: {custom_response}"
        finally:
            server.stop()
    
    def test_http_auth_failure_wrong_password(self):
        """Test HTTP auth failure with wrong password"""
        port = 8769
        server = TestHTTPServer(port, 'admin', 'admin', 'success')
        server.start()
        
        try:
            result = vulnerability_scanner.try_http_auth('127.0.0.1', port, 'admin', 'wrongpass')
            assert result is None, "Should return None for wrong password"
        finally:
            server.stop()
    
    def test_http_auth_failure_wrong_username(self):
        """Test HTTP auth failure with wrong username"""
        port = 8770
        server = TestHTTPServer(port, 'admin', 'admin', 'success')
        server.start()
        
        try:
            result = vulnerability_scanner.try_http_auth('127.0.0.1', port, 'wronguser', 'admin')
            assert result is None, "Should return None for wrong username"
        finally:
            server.stop()
    
    def test_http_auth_no_server(self):
        """Test HTTP auth when no server is running (exception handling)"""
        result = vulnerability_scanner.try_http_auth('127.0.0.1', 8999, 'admin', 'admin')
        assert result is None, "Should return None when server is not available"
    
    def test_http_auth_multiline_response(self):
        """Test HTTP auth with multiline server response"""
        port = 8771
        response = 'line1\nline2\nline3'
        server = TestHTTPServer(port, 'admin', 'admin', response)
        server.start()
        
        try:
            result = vulnerability_scanner.try_http_auth('127.0.0.1', port, 'admin', 'admin')
            assert result == response, "Should handle multiline responses"
        finally:
            server.stop()


class TestSSHAuthentication:
    """Test SSH password authentication functionality"""
    
    def test_ssh_auth_success_admin(self):
        """Test successful SSH auth with admin credentials"""
        port = 2345
        server = TestSSHServer(port, 'admin', 'admin', 'success')
        server.start()
        
        try:
            result = vulnerability_scanner.try_ssh_auth('127.0.0.1', port, 'admin', 'admin')
            assert result is not None, "Should successfully authenticate with admin:admin"
            assert 'success' in result or result == 'success', f"Should return 'success' or contain it, got: {result}"
        finally:
            server.stop()
    
    def test_ssh_auth_success_root(self):
        """Test successful SSH auth with root credentials"""
        port = 2346
        server = TestSSHServer(port, 'root', 'abc123', 'success')
        server.start()
        
        try:
            result = vulnerability_scanner.try_ssh_auth('127.0.0.1', port, 'root', 'abc123')
            assert result is not None, "Should successfully authenticate with root:abc123"
        finally:
            server.stop()
    
    def test_ssh_auth_success_skroob(self):
        """Test successful SSH auth with skroob credentials"""
        port = 2347
        server = TestSSHServer(port, 'skroob', '12345', 'success')
        server.start()
        
        try:
            result = vulnerability_scanner.try_ssh_auth('127.0.0.1', port, 'skroob', '12345')
            assert result is not None, "Should successfully authenticate with skroob:12345"
        finally:
            server.stop()
    
    def test_ssh_auth_custom_response(self):
        """Test SSH auth with custom server response (not 'success')"""
        port = 2348
        custom_response = 'schwartz'
        server = TestSSHServer(port, 'admin', 'admin', custom_response)
        server.start()
        
        try:
            result = vulnerability_scanner.try_ssh_auth('127.0.0.1', port, 'admin', 'admin')
            assert result is not None, "Should return a result"
            assert custom_response in result or result == custom_response, f"Should return or contain '{custom_response}'"
        finally:
            server.stop()
    
    def test_ssh_auth_failure_wrong_password(self):
        """Test SSH auth failure with wrong password"""
        port = 2349
        server = TestSSHServer(port, 'admin', 'admin', 'success')
        server.start()
        
        try:
            result = vulnerability_scanner.try_ssh_auth('127.0.0.1', port, 'admin', 'wrongpass')
            assert result is None, "Should return None for wrong password"
        finally:
            server.stop()
    
    def test_ssh_auth_failure_wrong_username(self):
        """Test SSH auth failure with wrong username"""
        port = 2350
        server = TestSSHServer(port, 'admin', 'admin', 'success')
        server.start()
        
        try:
            result = vulnerability_scanner.try_ssh_auth('127.0.0.1', port, 'wronguser', 'admin')
            assert result is None, "Should return None for wrong username"
        finally:
            server.stop()
    
    def test_ssh_auth_no_server(self):
        """Test SSH auth when no server is running (exception handling)"""
        result = vulnerability_scanner.try_ssh_auth('127.0.0.1', 2999, 'admin', 'admin')
        assert result is None, "Should return None when server is not available"


class TestOutputFormat:
    """Test RFC 3986 output format compliance"""
    
    def test_http_output_format(self):
        """Test exact HTTP output format: http://user:pass@host:port response"""
        port = 8772
        server = TestHTTPServer(port, 'admin', 'admin', 'success')
        server.start()
        
        try:
            time.sleep(0.3)
            result = subprocess.run(
                [sys.executable, 'vulnerability_scanner.py'],
                cwd=os.path.dirname(os.path.abspath(__file__)),
                capture_output=True,
                text=True,
                timeout=20
            )
            
            output = result.stdout.strip()
            expected_pattern = rf'http://admin:admin@127\.0\.0\.1:{port} success'
            
            assert re.search(expected_pattern, output), \
                f"Output should match RFC 3986 format. Got: '{output}'"
        finally:
            server.stop()
    
    def test_ssh_output_format(self):
        """Test exact SSH output format: ssh://user:pass@host:port response"""
        port = 2351
        server = TestSSHServer(port, 'skroob', '12345', 'schwartz')
        server.start()
        
        try:
            time.sleep(0.3)
            result = subprocess.run(
                [sys.executable, 'vulnerability_scanner.py'],
                cwd=os.path.dirname(os.path.abspath(__file__)),
                capture_output=True,
                text=True,
                timeout=20
            )
            
            output = result.stdout.strip()
            expected_pattern = rf'ssh://skroob:12345@127\.0\.0\.1:{port} schwartz'
            
            # Check if output contains the expected pattern
            assert re.search(expected_pattern, output) or 'ssh://skroob:12345@127.0.0.1' in output, \
                f"Output should match RFC 3986 format. Got: '{output}'"
        finally:
            server.stop()
    
    def test_output_has_single_space_separator(self):
        """Test that there's exactly one space between URL and response"""
        port = 8773
        server = TestHTTPServer(port, 'root', 'abc123', 'testresponse')
        server.start()
        
        try:
            time.sleep(0.3)
            result = subprocess.run(
                [sys.executable, 'vulnerability_scanner.py'],
                cwd=os.path.dirname(os.path.abspath(__file__)),
                capture_output=True,
                text=True,
                timeout=20
            )
            
            output = result.stdout.strip()
            if output:
                # Should have format: <url><space><response>
                lines = output.split('\n')
                for line in lines:
                    if 'root:abc123' in line:
                        parts = line.split(' ', 1)
                        assert len(parts) == 2, "Output should have URL, one space, and response"
                        assert parts[1] == 'testresponse', "Response text should be exact"
        finally:
            server.stop()
    
    def test_no_output_when_no_vulnerabilities(self):
        """Test that program outputs nothing when no vulnerabilities found"""
        # Don't start any servers
        result = subprocess.run(
            [sys.executable, 'vulnerability_scanner.py'],
            cwd=os.path.dirname(os.path.abspath(__file__)),
            capture_output=True,
            text=True,
            timeout=30
        )
        
        # Should output nothing or only newlines
        assert result.stdout.strip() == '', "Should output nothing when no vulnerabilities found"
        assert result.returncode == 0, "Should exit successfully even with no findings"


class TestExceptionHandling:
    """Test exception handling - no errors should be printed"""
    
    def test_no_errors_on_connection_refused(self):
        """Test that connection refused doesn't print errors"""
        result = subprocess.run(
            [sys.executable, 'vulnerability_scanner.py'],
            cwd=os.path.dirname(os.path.abspath(__file__)),
            capture_output=True,
            text=True,
            timeout=30
        )
        
        # stderr should be empty (no error messages)
        assert result.stderr == '', f"stderr should be empty, got: {result.stderr}"
    
    def test_no_errors_on_timeout(self):
        """Test that timeouts don't print errors"""
        # Create a server that doesn't respond properly
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('127.0.0.1', 8888))
        sock.listen(1)
        
        try:
            result = subprocess.run(
                [sys.executable, 'vulnerability_scanner.py'],
                cwd=os.path.dirname(os.path.abspath(__file__)),
                capture_output=True,
                text=True,
                timeout=35
            )
            
            assert result.stderr == '', f"stderr should be empty even on timeout, got: {result.stderr}"
        finally:
            sock.close()
    
    def test_no_traceback_in_output(self):
        """Test that no Python tracebacks appear in output"""
        result = subprocess.run(
            [sys.executable, 'vulnerability_scanner.py'],
            cwd=os.path.dirname(os.path.abspath(__file__)),
            capture_output=True,
            text=True,
            timeout=30
        )
        
        combined_output = result.stdout + result.stderr
        assert 'Traceback' not in combined_output, "No Python tracebacks should appear"
        assert 'Error' not in result.stderr, "No error messages should appear in stderr"
        assert 'Exception' not in combined_output, "No exception messages should appear"


class TestVerboseMode:
    """Test verbose mode (-v flag) functionality"""
    
    def test_verbose_flag_shows_extra_output(self):
        """Test that -v flag enables verbose output to stderr"""
        result = subprocess.run(
            [sys.executable, 'vulnerability_scanner.py', '-v'],
            cwd=os.path.dirname(os.path.abspath(__file__)),
            capture_output=True,
            text=True,
            timeout=30
        )
        
        # Verbose mode should print to stderr, not stdout
        # stdout should still only have vulnerability findings
        assert result.stderr != '', "Verbose mode should print debug info to stderr"
    
    def test_normal_mode_no_extra_output(self):
        """Test that normal mode (no -v) produces no extra output"""
        result = subprocess.run(
            [sys.executable, 'vulnerability_scanner.py'],
            cwd=os.path.dirname(os.path.abspath(__file__)),
            capture_output=True,
            text=True,
            timeout=30
        )
        
        # Normal mode should have empty stderr
        assert result.stderr == '', "Normal mode should not print to stderr"


class TestIntegration:
    """Integration tests with multiple services"""
    
    def test_multiple_http_servers(self):
        """Test scanning with multiple HTTP servers"""
        server1 = TestHTTPServer(8774, 'admin', 'admin', 'success')
        server2 = TestHTTPServer(8775, 'root', 'abc123', 'success')
        
        server1.start()
        server2.start()
        
        try:
            time.sleep(0.3)
            result = subprocess.run(
                [sys.executable, 'vulnerability_scanner.py'],
                cwd=os.path.dirname(os.path.abspath(__file__)),
                capture_output=True,
                text=True,
                timeout=25
            )
            
            output = result.stdout.strip()
            assert 'http://admin:admin@127.0.0.1:8774' in output, "Should find admin server"
            assert 'http://root:abc123@127.0.0.1:8775' in output, "Should find root server"
        finally:
            server1.stop()
            server2.stop()
    
    def test_multiple_ssh_servers(self):
        """Test scanning with multiple SSH servers"""
        server1 = TestSSHServer(2352, 'admin', 'admin', 'success')
        server2 = TestSSHServer(2353, 'skroob', '12345', 'schwartz')
        
        server1.start()
        server2.start()
        
        try:
            time.sleep(0.3)
            result = subprocess.run(
                [sys.executable, 'vulnerability_scanner.py'],
                cwd=os.path.dirname(os.path.abspath(__file__)),
                capture_output=True,
                text=True,
                timeout=25
            )
            
            output = result.stdout.strip()
            assert 'ssh://admin:admin@127.0.0.1:2352' in output, "Should find admin SSH server"
            assert 'ssh://skroob:12345@127.0.0.1:2353' in output, "Should find skroob SSH server"
        finally:
            server1.stop()
            server2.stop()
    
    def test_mixed_http_and_ssh_servers(self):
        """Test scanning with both HTTP and SSH servers"""
        http_server = TestHTTPServer(8776, 'admin', 'admin', 'success')
        ssh_server = TestSSHServer(2354, 'skroob', '12345', 'schwartz')
        
        http_server.start()
        ssh_server.start()
        
        try:
            time.sleep(0.3)
            result = subprocess.run(
                [sys.executable, 'vulnerability_scanner.py'],
                cwd=os.path.dirname(os.path.abspath(__file__)),
                capture_output=True,
                text=True,
                timeout=25
            )
            
            output = result.stdout.strip()
            assert 'http://admin:admin@127.0.0.1:8776' in output, "Should find HTTP server"
            assert 'ssh://skroob:12345@127.0.0.1:2354' in output, "Should find SSH server"
        finally:
            http_server.stop()
            ssh_server.stop()
    
    def test_all_credentials_tested(self):
        """Test that all three credential pairs are tested"""
        # Create three servers, each with different credentials
        server1 = TestHTTPServer(8777, 'admin', 'admin', 'found_admin')
        server2 = TestHTTPServer(8778, 'root', 'abc123', 'found_root')
        server3 = TestHTTPServer(8779, 'skroob', '12345', 'found_skroob')
        
        server1.start()
        server2.start()
        server3.start()
        
        try:
            time.sleep(0.3)
            result = subprocess.run(
                [sys.executable, 'vulnerability_scanner.py'],
                cwd=os.path.dirname(os.path.abspath(__file__)),
                capture_output=True,
                text=True,
                timeout=25
            )
            
            output = result.stdout.strip()
            assert 'admin:admin' in output, "Should test admin credentials"
            assert 'root:abc123' in output, "Should test root credentials"
            assert 'skroob:12345' in output, "Should test skroob credentials"
            assert 'found_admin' in output, "Should find admin response"
            assert 'found_root' in output, "Should find root response"
            assert 'found_skroob' in output, "Should find skroob response"
        finally:
            server1.stop()
            server2.stop()
            server3.stop()


class TestRealHW5Servers:
    """Integration tests with actual hw5_server instances"""
    
    def test_with_real_http_server(self):
        """Test with actual hw5_server http_server.py"""
        # Start the real http_server
        http_proc = subprocess.Popen(
            [sys.executable, 'hw5_server-main/http_server.py', '--port', '8780', '--username', 'admin', '--password', 'admin'],
            cwd=os.path.dirname(os.path.abspath(__file__)),
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        
        try:
            time.sleep(1)  # Let server start
            
            result = subprocess.run(
                [sys.executable, 'vulnerability_scanner.py'],
                cwd=os.path.dirname(os.path.abspath(__file__)),
                capture_output=True,
                text=True,
                timeout=25
            )
            
            output = result.stdout.strip()
            assert 'http://admin:admin@127.0.0.1:8780 success' in output, \
                f"Should detect real HTTP server. Got: {output}"
        finally:
            http_proc.terminate()
            http_proc.wait(timeout=5)
    
    def test_with_real_ssh_server(self):
        """Test with actual hw5_server ssh_server.py"""
        # Start the real ssh_server
        ssh_proc = subprocess.Popen(
            [sys.executable, 'hw5_server-main/ssh_server.py', '--port', '2355', '--username', 'skroob', '--password', '12345'],
            cwd=os.path.dirname(os.path.abspath(__file__)),
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        
        try:
            time.sleep(1.5)  # Let server start
            
            result = subprocess.run(
                [sys.executable, 'vulnerability_scanner.py'],
                cwd=os.path.dirname(os.path.abspath(__file__)),
                capture_output=True,
                text=True,
                timeout=25
            )
            
            output = result.stdout.strip()
            assert 'ssh://skroob:12345@127.0.0.1:2355' in output, \
                f"Should detect real SSH server. Got: {output}"
            assert 'success' in output, "Should get success response from real SSH server"
        finally:
            ssh_proc.terminate()
            ssh_proc.wait(timeout=5)
    
    def test_grading_scenario(self):
        """Test exact grading scenario from homework spec"""
        # Start both servers as specified in homework
        http_proc = subprocess.Popen(
            [sys.executable, 'hw5_server-main/http_server.py', '--port', '8080', '--username', 'admin', '--password', 'admin'],
            cwd=os.path.dirname(os.path.abspath(__file__)),
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        
        ssh_proc = subprocess.Popen(
            [sys.executable, 'hw5_server-main/ssh_server.py', '--port', '2222', '--username', 'skroob', '--password', '12345'],
            cwd=os.path.dirname(os.path.abspath(__file__)),
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        
        try:
            time.sleep(2)  # Let both servers start
            
            result = subprocess.run(
                [sys.executable, 'vulnerability_scanner.py'],
                cwd=os.path.dirname(os.path.abspath(__file__)),
                capture_output=True,
                text=True,
                timeout=30
            )
            
            output = result.stdout.strip()
            lines = output.split('\n')
            
            # Check for expected outputs (order may vary)
            expected_http = 'http://admin:admin@127.0.0.1:8080 success'
            expected_ssh_pattern = r'ssh://skroob:12345@127\.0\.0\.1:2222 success'
            
            assert any(expected_http in line for line in lines), \
                f"Should find HTTP vulnerability. Got: {output}"
            assert any(re.match(expected_ssh_pattern, line) for line in lines), \
                f"Should find SSH vulnerability. Got: {output}"
            
            # Verify no other output
            assert result.stderr == '', "Should have no stderr output in normal mode"
            
        finally:
            http_proc.terminate()
            ssh_proc.terminate()
            http_proc.wait(timeout=5)
            ssh_proc.wait(timeout=5)


class TestSQLInjectionPayload:
    """Test attack.json SQL injection payload"""
    
    def test_attack_json_exists(self):
        """Verify attack.json file exists"""
        attack_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'attack.json')
        assert os.path.exists(attack_file), "attack.json must exist"
    
    def test_attack_json_valid_format(self):
        """Verify attack.json is valid JSON"""
        attack_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'attack.json')
        with open(attack_file, 'r') as f:
            data = json.load(f)
        
        assert isinstance(data, dict), "attack.json should be a JSON object"
        assert 'measure_name' in data, "attack.json should have measure_name field"
    
    def test_attack_json_has_limit_100(self):
        """Verify attack.json includes LIMIT 100 clause - CRITICAL for grading"""
        attack_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'attack.json')
        with open(attack_file, 'r') as f:
            data = json.load(f)
        
        payload = data.get('measure_name', '')
        assert 'LIMIT 100' in payload or 'limit 100' in payload.lower(), \
            "attack.json MUST include 'LIMIT 100' - required for grading!"
    
    def test_attack_json_has_sql_injection(self):
        """Verify attack.json contains SQL injection syntax"""
        attack_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'attack.json')
        with open(attack_file, 'r') as f:
            data = json.load(f)
        
        payload = data.get('measure_name', '')
        # Should have injection components
        assert "'" in payload, "SQL injection should include quote character"
        assert 'OR' in payload.upper() or '1=1' in payload, "SQL injection should have OR clause"
    
    def test_test_json_exists(self):
        """Verify test.json file exists"""
        test_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'test.json')
        assert os.path.exists(test_file), "test.json must exist"
    
    def test_test_json_valid_format(self):
        """Verify test.json is valid JSON"""
        test_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'test.json')
        with open(test_file, 'r') as f:
            data = json.load(f)
        
        assert isinstance(data, dict), "test.json should be a JSON object"


class TestRepositoryRequirements:
    """Test repository structure and required files"""
    
    def test_all_required_files_exist(self):
        """Verify all required files exist"""
        base_dir = os.path.dirname(os.path.abspath(__file__))
        required_files = [
            'vulnerability_scanner.py',
            'attack.json',
            'test.json',
            'prompts.txt',
            'requirements.txt',
            'README.md',
            '.gitignore'
        ]
        
        for filename in required_files:
            filepath = os.path.join(base_dir, filename)
            assert os.path.exists(filepath), f"Required file missing: {filename}"
    
    def test_vulnerability_scanner_has_authorship(self):
        """Verify vulnerability_scanner.py includes authorship attribution"""
        scanner_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'vulnerability_scanner.py')
        with open(scanner_file, 'r') as f:
            content = f.read()
        
        # Should have author attribution
        assert 'Author' in content or 'author' in content, \
            "vulnerability_scanner.py must include authorship attribution"
    
    def test_vulnerability_scanner_is_executable(self):
        """Verify vulnerability_scanner.py is executable"""
        scanner_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'vulnerability_scanner.py')
        with open(scanner_file, 'r') as f:
            first_line = f.readline()
        
        assert first_line.startswith('#!'), \
            "vulnerability_scanner.py should have shebang line"
    
    def test_requirements_txt_has_dependencies(self):
        """Verify requirements.txt includes necessary dependencies"""
        req_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'requirements.txt')
        with open(req_file, 'r') as f:
            content = f.read().lower()
        
        required_deps = ['python-nmap', 'paramiko', 'requests']
        for dep in required_deps:
            assert dep in content, f"requirements.txt should include {dep}"
    
    def test_gitignore_excludes_caches(self):
        """Verify .gitignore excludes Python caches"""
        gitignore_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), '.gitignore')
        with open(gitignore_file, 'r') as f:
            content = f.read()
        
        assert '__pycache__' in content or '*.pyc' in content, \
            ".gitignore should exclude Python caches"


class TestEdgeCases:
    """Test edge cases and error conditions"""
    
    def test_port_boundary_8999(self):
        """Test port scanning at boundary (8999 should be included)"""
        port = 8999
        server = TestHTTPServer(port, 'admin', 'admin', 'success')
        server.start()
        
        try:
            time.sleep(0.3)
            result = vulnerability_scanner.scan_ports('127.0.0.1')
            # 8999 should be in the scan range
            if port in [p for p in result]:
                # If we found it open, test it
                result = subprocess.run(
                    [sys.executable, 'vulnerability_scanner.py'],
                    cwd=os.path.dirname(os.path.abspath(__file__)),
                    capture_output=True,
                    text=True,
                    timeout=20
                )
                assert f'127.0.0.1:{port}' in result.stdout or True, "Should handle port 8999"
        finally:
            server.stop()
    
    def test_empty_server_response(self):
        """Test handling of empty server response"""
        port = 8781
        server = TestHTTPServer(port, 'admin', 'admin', '')
        server.start()
        
        try:
            result = vulnerability_scanner.try_http_auth('127.0.0.1', port, 'admin', 'admin')
            # Should handle empty response gracefully
            assert result is not None or result is None, "Should handle empty response"
        finally:
            server.stop()
    
    def test_special_characters_in_response(self):
        """Test handling of special characters in server response"""
        port = 8782
        special_response = "test\r\n\t!@#$%^&*()"
        server = TestHTTPServer(port, 'admin', 'admin', special_response)
        server.start()
        
        try:
            result = vulnerability_scanner.try_http_auth('127.0.0.1', port, 'admin', 'admin')
            assert result is not None, "Should handle special characters in response"
        finally:
            server.stop()
    
    def test_long_server_response(self):
        """Test handling of long server response"""
        port = 8783
        long_response = 'x' * 10000
        server = TestHTTPServer(port, 'admin', 'admin', long_response)
        server.start()
        
        try:
            result = vulnerability_scanner.try_http_auth('127.0.0.1', port, 'admin', 'admin')
            assert result is not None, "Should handle long server responses"
            assert len(result) > 0, "Should capture long response"
        finally:
            server.stop()
    
    def test_concurrent_connections(self):
        """Test scanner handles concurrent connection attempts"""
        server1 = TestHTTPServer(8784, 'admin', 'admin', 'success1')
        server2 = TestHTTPServer(8785, 'root', 'abc123', 'success2')
        server3 = TestSSHServer(2356, 'skroob', '12345', 'success3')
        
        server1.start()
        server2.start()
        server3.start()
        
        try:
            time.sleep(0.3)
            result = subprocess.run(
                [sys.executable, 'vulnerability_scanner.py'],
                cwd=os.path.dirname(os.path.abspath(__file__)),
                capture_output=True,
                text=True,
                timeout=30
            )
            
            # Should find all three
            output = result.stdout
            assert '8784' in output or '8785' in output or '2356' in output, \
                "Should handle multiple concurrent servers"
        finally:
            server1.stop()
            server2.stop()
            server3.stop()


class TestCredentialsDictionary:
    """Test that exact credentials from spec are used"""
    
    def test_credentials_match_spec(self):
        """Verify credentials dictionary matches homework specification exactly"""
        # Expected credentials from spec
        expected_credentials = {
            'admin': 'admin',
            'root': 'abc123',
            'skroob': '12345'
        }
        
        # Check that these are defined in the module
        assert hasattr(vulnerability_scanner, 'credentials') or True, \
            "Should use credentials dictionary"
        
        # Test that all three work
        servers = [
            (8786, 'admin', 'admin'),
            (8787, 'root', 'abc123'),
            (8788, 'skroob', '12345')
        ]
        
        test_servers = []
        for port, user, password in servers:
            s = TestHTTPServer(port, user, password, 'success')
            s.start()
            test_servers.append(s)
        
        try:
            time.sleep(0.3)
            result = subprocess.run(
                [sys.executable, 'vulnerability_scanner.py'],
                cwd=os.path.dirname(os.path.abspath(__file__)),
                capture_output=True,
                text=True,
                timeout=25
            )
            
            output = result.stdout
            assert 'admin:admin' in output, "Should test admin:admin"
            assert 'root:abc123' in output, "Should test root:abc123"
            assert 'skroob:12345' in output, "Should test skroob:12345"
        finally:
            for s in test_servers:
                s.stop()


# ============================================================================
# MAIN TEST RUNNER
# ============================================================================

if __name__ == '__main__':
    pytest.main([__file__, '-v', '--tb=short'])

